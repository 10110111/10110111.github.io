<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="logo.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CalcMySky: ShowMySky API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CalcMySky
   &#160;<span id="projectnumber">v0.0.4-1-g16875c4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ShowMySky API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ShowMySky uses Qt for its rendering and data processing, so the API reflects this: it relies on <code>QOpenGLFunctions_3_3_Core</code>, <code>QOpenGLShaderProgram</code>, <code>QString</code> etc.</p>
<p>To use ShowMySky from your C++ application, you need to do the following.</p>
<h2>Initializing atmosphere renderer</h2>
<ol type="1">
<li><b>Include the header.</b> In the C++ source include <a href="api_2AtmosphereRenderer_8hpp.html"><code>&lt;ShowMySky/AtmosphereRenderer.hpp&gt;</code></a> to get access to the relevant classes.</li>
<li><b>Load ShowMySky library.</b> This can be done either by linking to it directly as a usual shared object, or by <code>dlopen</code>/<code>LoadLibrary[Ex]</code>/<code>QLibrary::load</code> etc..</li>
<li><b>Check ABI verison.</b> To do this, find a symbol named <code>ShowMySky_ABI_version</code> of type <code>uint32_t</code> in the loaded library (via <code>dlsym</code>/<code>GetProcAddress</code>/<code>QLibrary::resolve</code> etc.), compare its value with <a class="el" href="api_2AtmosphereRenderer_8hpp.html#a1d7584bed9b2ab49dabef29398262930" title="ABI version of the header.">ShowMySky_ABI_version</a> macro defined in the header included in step 1. If it doesn't match, the library is incompatible with the header, use of such a library has undefined behavior.</li>
<li><b>Locate API entry point.</b> If ABI version is validated successfully in step 3, then find a symbol named <a class="el" href="api_2AtmosphereRenderer_8hpp.html#a9cb14ed91ad9de5d8578034a818b6121" title="Entry point for the creator of AtmosphereRenderer.">ShowMySky_AtmosphereRenderer_create</a> with the function-pointer type <code>decltype(ShowMySky_AtmosphereRenderer_create)</code>.</li>
<li><b>Create the settings object.</b> To provide the renderer with the necessary settings, ShowMySky uses a helper interface, <a class="el" href="classShowMySky_1_1Settings.html" title="Scene settings for AtmosphereRenderer.">ShowMySky::Settings</a>. This interface must be implemented by some object in the application. A pointer to this object will later be supplied to the constructor of the renderer.</li>
<li><b>Create a function to render target OpenGL surface.</b> See <a href="#surface-and-view-dir">Surface rendering and view direction shader</a> section for details.</li>
<li><b>Construct <code><a class="el" href="classAtmosphereRenderer.html">AtmosphereRenderer</a></code>.</b> This is done by calling <a class="el" href="api_2AtmosphereRenderer_8hpp.html#a9cb14ed91ad9de5d8578034a818b6121" title="Entry point for the creator of AtmosphereRenderer.">ShowMySky_AtmosphereRenderer_create</a>, the function resolved in step 4, passing path to the atmosphere model directory, as well as a pointer to <code>QOpenGLFunctions_3_3_Core</code> for the OpenGL context in which the renderer will work.</li>
</ol>
<h2><a class="anchor" id="surface-and-view-dir"></a> Surface rendering and view direction shader </h2>
<p>In OpenGL there are many ways to draw a surface to be displayed on the screen or saved into a texture. One of the simplest ways is to draw a single <code>GL_QUADS</code> item, having set up current vertex array and supplied the necessary uniforms to the current shader program. Here's an example of such a surface rendering function:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::function drawSurface=[](QOpenGLShaderProgram&amp; program)</div><div class="line">{</div><div class="line">    program.setUniformValue(<span class="stringliteral">&quot;zoomFactor&quot;</span>, zoomFactor());</div><div class="line">    program.setUniformValue(<span class="stringliteral">&quot;cameraRotation&quot;</span>, calcCamRotation());</div><div class="line">    glBindVertexArray(vao_);</div><div class="line">    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);</div><div class="line">    glBindVertexArray(0);</div><div class="line">};</div></div><!-- fragment --><p>Aside from the many ways to draw a surface, there's a lot of different projections to choose from, as well as different connections of the their parameters to the surface drawing process. Thus, we need some way to find out what direction in the physical 3D space a given pixel on the surface corresponds to. ShowMySky API makes it possible for the app to provide its own shaders (vertex and fragment) that implement the function that takes no arguments and yields the direction in 3D space.</p>
<p>The coordinate system is such that north is along the \(x\) axis, west is along the \(y\) axis, and zenith is along the \(z\) axis.</p>
<p>Here's an example of the vertex and fragment shaders that implement this function to work in tandem with the <code>drawSurface</code> example above:</p>
<div class="fragment"><div class="line"><span class="comment">// Vertex shader</span></div><div class="line"><span class="preprocessor">#version 330</span></div><div class="line">in vec3 vertex;</div><div class="line">out vec3 position;</div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    position=vertex;</div><div class="line">    gl_Position=vec4(position,1);</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Fragment shader</span></div><div class="line"><span class="preprocessor">#version 330</span></div><div class="line">in vec3 position;</div><div class="line">uniform <span class="keywordtype">float</span> zoomFactor;</div><div class="line">uniform mat3 cameraRotation;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> PI=3.1415926535897932;</div><div class="line">vec3 calcViewDir()</div><div class="line">{</div><div class="line">    vec2 pos=position.xy/zoomFactor;</div><div class="line">    <span class="comment">// pos.x and pos.y are supposed to vary from -1 to 1.</span></div><div class="line">    <span class="comment">// The following computation implements equirectangular</span></div><div class="line">    <span class="comment">// projection with the center defined by cameraRotation.</span></div><div class="line">    <span class="keywordflow">return</span> cameraRotation*vec3(cos(pos.x*PI)*cos(pos.y*(PI/2)),</div><div class="line">                               sin(pos.x*PI)*cos(pos.y*(PI/2)),</div><div class="line">                               sin(pos.y*(PI/2)));</div><div class="line">}</div></div><!-- fragment --><h2>Loading atmosphere model</h2>
<p>Data loading is a bit involved. Because loading can potentially take dozens of seconds (for heavy models), it's done in steps, making it possible for application to indicate progress in the UI instead of freezing for the duration of loading. The procedure is as follows:</p>
<ol type="1">
<li>Prepare source code for the shaders that implement <code>calcViewDir</code> function (see <a href="#surface-and-view-dir">Surface rendering and view direction shader</a> section for details).</li>
<li>Initialize the loading process by a call to <a class="el" href="classShowMySky_1_1AtmosphereRenderer.html#a1e6e3e7f90c728eccf0e9ac3fc9aa0b7" title="Initialize step-by-step process of loading of data.">ShowMySky::AtmosphereRenderer::initDataLoading</a>. If initialization fails (e.g. data path doesn't exist), this function will throw <a class="el" href="classShowMySky_1_1Error.html" title="An error that ShowMySky classes may throw.">ShowMySky::Error</a>. The return value of this function is the total number of loading steps to do.</li>
<li>Repeatedly call <a class="el" href="classShowMySky_1_1AtmosphereRenderer.html#ae24c7d91e27d66f55594be037480d4c7" title="Perform a single step of data loading.">ShowMySky::AtmosphereRenderer::stepDataLoading</a>, checking its return value. If this function fails (e.g. a data file is missing), it will throw <a class="el" href="classShowMySky_1_1Error.html" title="An error that ShowMySky classes may throw.">ShowMySky::Error</a>. The return value tells current progress that can be used in the UI. When number of steps done becomes equal to number of steps to do, loading is finished.</li>
</ol>
<h2>Rendering</h2>
<p>Readiness of the renderer to rendering can be queried by a call to <a class="el" href="classShowMySky_1_1AtmosphereRenderer.html#a2e50ddc43a31c61a3ed0c703226b4e2a" title="Tell whether the renderer is ready for a draw call.">ShowMySky::AtmosphereRenderer::isReadyToRender</a>. Once <code>true</code> is returned, basic rendering can be done by calling <a class="el" href="classShowMySky_1_1AtmosphereRenderer.html#a0e540b9fba02316c3c114264f1b898db" title="Do the drawing.">ShowMySky::AtmosphereRenderer::draw</a>. If textures need to be reloaded (see below), reloading is done synchronously, which may throw <a class="el" href="classShowMySky_1_1Error.html" title="An error that ShowMySky classes may throw.">ShowMySky::Error</a> if it fails.</p>
<p>In some cases the <code>draw</code> call may take much longer than it normally would. This is because, to avoid loading the whole textures into VRAM, only a slice of texture data corresponding to current camera altitude (determined by <a class="el" href="classShowMySky_1_1Settings.html#a7cff2bbe744013a1201ba2a0e3c2beb5" title="Camera altitude.">ShowMySky::Settings::altitude</a>) is loaded. When camera altitude changes, there may be a need to reload another slice. If the application simply calls <a class="el" href="classShowMySky_1_1AtmosphereRenderer.html#a0e540b9fba02316c3c114264f1b898db" title="Do the drawing.">ShowMySky::AtmosphereRenderer::draw</a>, the reloading may take some time, making the application appear to freeze.</p>
<p>To avoid freezes, the application can drive the reloading step by step. To implement this, the following steps are needed.</p>
<ol type="1">
<li>Initialize preparation to draw by calling <a class="el" href="classShowMySky_1_1AtmosphereRenderer.html#a86576414d9bde47e40d806682a115ce4" title="Initialize step-by-step process of preparation to render.">ShowMySky::AtmosphereRenderer::initPreparationToDraw</a>. If the return value is zero, there's no need to reload anything, so drawing can be done as usual. Otherwise, the return value tells the total number of steps to be taken for reloading.</li>
<li>If there's a nonzero number of steps to take, repeatedly call <a class="el" href="classShowMySky_1_1AtmosphereRenderer.html#aa8ee069016fd3cd836d8322bcb58ed79" title="Perform a single step of preparation to draw.">ShowMySky::AtmosphereRenderer::stepPreparationToDraw</a>. If this function fails, it throws <a class="el" href="classShowMySky_1_1Error.html" title="An error that ShowMySky classes may throw.">ShowMySky::Error</a>. Return value of this function indicates progress of reloading: number of steps done and total number of steps to do. This can be used in the UI.</li>
<li>Now call <a class="el" href="classShowMySky_1_1AtmosphereRenderer.html#a0e540b9fba02316c3c114264f1b898db" title="Do the drawing.">ShowMySky::AtmosphereRenderer::draw</a> to actually render the scene. </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
